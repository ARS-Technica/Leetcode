"""
1582. Special Positions in a Binary Matrix
Easy
https://leetcode.com/problems/special-positions-in-a-binary-matrix/ 

Given an m x n binary matrix mat, return the number of special positions in mat.

A position (i, j) is called special if mat[i][j] == 1 and all other elements 
in row i and column j are 0 (rows and columns are 0-indexed).

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 100
mat[i][j] is either 0 or 1.
"""


class Solution:
    def numSpecial(self, mat): 
        ones = []
        first, second = [], []

        for i in range(len(mat)):
            for j in range(len(mat[i])): 
                if mat[i][j] == 1: 
                    ones.append((i,j))
                    first.append(i)
                    second.append(j)


        first_counts = [n for n in first if first.count(n) == 1]
        second_counts = [n for n in second if second.count(n) == 1]


        return len([tup for tup in ones if tup[0] in first_counts and tup[1] in second_counts])


if __name__ == "__main__":
    lc = Solution() 
    print(lc.numSpecial(mat = [[1,0,0],[0,0,1],[1,0,0]]))   # 1
    print(lc.numSpecial(mat = [[1,0,0],[0,1,0],[0,0,1]]))   # 3 
    print(lc.numSpecial(mat = [[0,0,0,0,0,1,0,0],
                               [0,0,0,0,1,0,0,1],
                               [0,0,0,0,1,0,0,0],
                               [1,0,0,0,1,0,0,0],
                               [0,0,1,1,0,0,0,0]]))         # 1 


# Runtime: 2721 ms, faster than 5.23% of Python3 online submissions for Special Positions in a Binary Matrix.
# Memory Usage: 14.9 MB, less than 6.54% of Python3 online submissions for Special Positions in a Binary Matrix.


#%%
